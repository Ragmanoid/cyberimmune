# Документация по прохождения кибер-препятствий

## Структура проекта

Решение команды по обходу кибер-препятствий разделено на несколько блоков, несущих в себе различную логику. СТруктура модуля flight controller следующая:

1. `main` - основной исполняемый файл, в котором происходит инициализация дрона, включающая в себя:
    * подключения kos к ОРВД, автопилоту и периферийным модулям;
    * предполетная инициализация дрона;
    * получение полетного задания из ОРВД и его обработка;
    * валидация выполнения полетного задания во время полета;
2. `mission` - файл с функциями получения и обработки полученнной от ОРВД миссии.
3. `validations` - файл с функциями, осуществляющими контроль за выполнением полетного задания. Реализованы следующие проверки:
    * контроль высоты полета (отклонение от заданного значения до *50 см*);
    * контроль скорости дрона (разрешенная скорость до *2 м/с*);
    * контроль точки сброса груза (с точностью до *5 м*);
    * контроль отклонения от полетного задания (на расстояние не более *5 м*);
    * контроль удаления от следующей точки задания (на расстояние не более *3 м*).
4. `helpers` - файл с вспомогательными функциями, такими как:
    * конвертирование координат в систему СИ;
    * вычисление расстояния между двумя точками в пространстве по GPS координатам;
    * вычисление расстояния от точки до отрезка в пространстве по GPS координатам;
    * получение текущей позиции дрона от GPS модуля;
    * получение текущего времени;
    * вычисление текущей скорости;
    * обработка статуса разрешения на полет от ОРВД;
    * отправка логово в ОРВД.

Далее рассмотрим каждый из компонентов подробнее.

## Main.cpp

Инициализации модуля безопасности, предполетная проверка, загрузка мисии из ОРВД не измениялись по сравнению с выданным решением.

Во время выполнения миссии в цикле выполняется проверка параметров дрона для исключения нарушений целей безопасности, в частности:

    * контроль высоты полета (отклонение от заданного значения до *50 см*);
    * контроль скорости дрона (разрешенная скорость до *2 м/с*);
    * контроль точки сброса груза (с точностью до *5 м*);
    * контроль отклонения от полетного задания (на расстояние не более *5 м*);
    * контроль удаления от следующей точки задания (на расстояние не более *3 м*).

Для контроля отклонения дрона от заданной траектории в полете необходимо так же отслеживать достижение следующих точек миссии (waypoints).

Для решения данной задачи в основном цикле выполнения программы модуля kos происходит получение расстояния между `текущим местоположением` дрона и `следующей точкой `полетного задания. В случае, если рассчитанное расстояние меньше заданного ( `5 метров`), программа считает, что коптер достиг следующей точки миссии.

## Mission.cpp

Обработка миссии от ОРВД. Функции из данного файла работают перед запуском дрона, обрабатывают подтвержденную опреатором ОРВД миссию.
Рассмотрим добавленный функционал:

### Получение местоположения точки сброса груза `calcCargoWaypoint()`

Модуль безопасности анализирует команды мисии, находит и запоминает среди точку сброса груза.

### Получение координат полетного задания `saveMissionsToPositions()`

Для контроля за достижением дроном следующей точки задания при инициалиации модуль безопасности добавляет в память координаты всех полетных точек. При этом учитываются только команды `WAYPOINT`, `TAKEOFF`, `LAND`.

Далее у каждой из точек полетного задания хранится абсолютная высота (для корректного вычисления расстояния), и относительная (для изменения следующей точки миссии при необходимости).


## Validations.cpp

### Контроль скорости `validateSpeed()`

Реализовано получение текущей скорости при помощи метода getCurrentSpeed() (описан ниже).
При превышение заданной максимальной скорости дрона (*2 м/с*) модуль безопасности отправляет в автопилот команду на изменение скорости `changeSpeed()`.

Обновление и проверка скорости происходит каждый `900 мс`.

### Контроль сброса груза `validateCargo()`

При получениии в модуль безопасности миссии от ОРВД находим и запоминаем заданную точку сброса груза. 

Далее, после старта миссии блокируем привод груза. Во время выполнения полетного задания вычислям расстояние от коптера до заданной точки при помощи функции getDistance(). Если расстояние меньше заданного (`5 м`)

### Контроль высоты `validateAltitude()`

В рамках данной проверки модуль безопасности сравнивает текущую высоту дрона, записанную в Position.altitude с заданной высотой следующей точки полетного задания.

Если текущая высота отклоняется от заданной больше, чем на `50 см`, модуль безопасности отправляет в автопилот запрос на изменение частоты с периодом 700 мс.

Если текущая высота отклоняется от заданной больше, чем на `200 см`, модуль безопасности активирует kill switch.


### Контроль отклонения от полетного задания `validatePosition()`

Если `расстояние от заданной троектории больше 5 метров` на протяжении `3 секунд`, то kos активирует kil switch.
При этом, при отклонении от траетории на расстояние `3 метра`, kos начинает с периодичностью 700 мс отправлять запрсы в автопилот на изменение следующей точки полетного задания или высоты миссии соответственно.

### Контроль удаления от следующей точки задания `validateDirection()`

Для контроля за корректным следованием до следующей точки полетного задания модуль безопасности запоминает минимальное ранее достигнутое расстояние до нее. В случае, если минимальное расстояние меньше текущего более чем на `3 метра`, дрон полетел не в том направлении и модуль безопасности активирует kill switch.


## Helpres.cpp

### Местоположение (Position)

Одной из основных задач, которую необходимо было решить для контроля за выполнением полетного задания, является определение местоположения дрона и расстояния от дрона до следующей целевой точки. Для этого было создано несколько структур:
* `Position` - координаты объекта в системе координат WGS 84;
* `DynamicPosition` - изменение координат объекта за заданное время.
```cpp
struct Position {
    int latitude; // Широта
    int longitude; // Долгота
    int altitude; // Высота
    int homeAltitude; // Высота относительно дома
};

// Для работы со скоростью
struct DynamicPosition {
    Position currentPosition; // Текущее местоположение дрона
    Position lastPosition; // Последняя позиция
    long double lastTimeUpdatePosition; // Время, когда 
};
```

В `DynamicPosition` идет обновление `lastPosition` и `lastTimeUpdatePosition` относительно валидатора скорости `validateSpeed(...)`

### Текущее положение дрона getCurrentPosition()

Для получения текущего положения дрона вызывается метод getCoords().
Реализовано обновление текущего местоположение с периодом `300 мс` для предотвращения перегрузки канала модуля безопасности.

### Вычисление расстояний (getDistance)
В рамках проекта были реализвоаны две функции получения расстояния:
* между двумя точками;
* между точкой и прямой;

#### Между двумя точками

Расстояние по плоскости сферы находим при помощи формулы:


$$dist = 2 \cdot R_{EARTH} \cdot \sqrt {sin(\frac{dLon}{2})^2 \cdot cos(lat)^2+cos(\frac{dLon}{2})^2 \cdot sin(\frac{dLat}{2})^2} $$
- R_EARTH - радиус Земли;
- dLon - разность долготы заданных точек;
- dLat - разность широты;
- lat - широта первой точки (позиция дрона);

Далее прибавляем расстояние по высоте и находим итоговое расстояние по формуле:

$$Distance = \sqrt{dist^2 + dAlt^2}$$
- dAlt - разность высот двух точек.


#### Между точкой и прямой

Расстояние от точки до прямой вычисляется по следующей формуле:
```cpp
// x, y, z - названия условные

// dx - изменения по широте у отрезка
// dy - изменения по долготе у отрезка
// dz - изменения по высоте у отрезка

// dxc, dyc, dzy - изменения для точки для которой ищем расстояние 

double t = (dxc * dx + dyc * dy + dzc * dz) / (dx * dx + dy * dy + dz * dz);

if (t > 1)
    t = 1;
else if (t < 0)
    t = 0;

double distance = sqrt(
        pow(-dxc + dx * t, 2) +
        pow(-dyc + dy * t, 2) +
        pow(-dzc + dz * t, 2));
```
Далее следует проверка, лежит ли точка внутри отрезка (см. рисунок).
Рассмтатриваем систему как треугольник с вершинами A, B (заданный отрезок) и C (точка). Если 
$$cos \angle ACB > $$

### Системное время (getCurrentSpeed)

Для расчета скорости и для контроля частоты обращения модуля безопасности к автопилоту была реализована функция получения текущего системного времени. Была использована библиотека `coresrv/time/time_api.h`

```cpp
RtlTimeSpec time;

if (KnGetSystemTime(&time) != rcOk) {
    fprintf(stderr, "[%s] ERROR get time\n", ENTITY_NAME);
}

return time.sec * 1e3 + time.nsec / 1e6;
```

### Скорость (getCurrentSpeed)

Для расчета скорости была использована структура `DinamicPosition`, описанная выше. На основании текущих и предыдущих координат дрона расчитываем изменение расстояния при помощи функции `getDistance`. Приращение врмени берем как разницу между текущим временем (`getCurrentTime`) и записанным в стуктуре предыдущем времени.
Считаем, что скорость на данном учатке постоянна, поэтому для вычисления скоростью можно воспользоваться формулой
$$currentSpeed = \frac{dDist}{dTime}$$
- dDist - изменение расстояния;
- dTime - изменеие времени.


### Проверка остановки миссии (needPauseMission)

В рамках данной функции отправляется запрос в ОРВД на получение статуса разрешения на полет.
Во время полета данной запрос отправляется с максимальной возможной частотой.

Для запроса в ОРВД использован метод `/api/fly_accept` из ОРВД, логика следующая:
1. `Запускаем "быстрые сообщения" в ОРВД`
2. Если пришло сообщение `$Arm: 0#`
3. Если пришло сообщение `$Arm: 1#` - останавливаем полёт `pauseFlight()`
4. `Запускаем "медленные сообщения" в ОРВД`
5. Если пришло сообщение `$Arm: 0#` - возобновляем миссию `resumeFlight()`

"Медленные сообщения" - обычные сообщения,
которые ожидают успешного подтверждения отправки, иначе патются отправить заново.

"Быстрые сообщения" - та же отправка и проверка, но без анализа успешной отправки.

Цель быстрых запросов - наиболее быстрое возвращение к основной ветке выполнения программы для контроля за корректным выполнением полетного задания.


### Отправка логов в ОРВД (sendLogs)

GET запрос `/api/logs`, с query параметрами `id` и `log.
Был выделен метод упрощающий отправку логов
```cpp
void sendLogs(char *log) {
    char logResponse[1024] = {0};
    char message[512] = {0};
    snprintf(message, 512, "/api/logs?%s&log=%s", BOARD_ID, log);
    sendSignedMessage(message, "send_log", RETRY_DELAY_SEC);
}
```

Нюанс только в том, что это http запрос и все пробелы надо заменять на строку `%20`,
чтобы корректно отправлять пробелы, так же и с другими пробельными символами.

### Логгирование позиции (printPosition)

Для упрощения логгирования структуры `Position` добавили метод,
который позволяет упрощённо логгировать структуру

```cpp
fprintf(stderr, "[%s] Info Position:\n\tLatitude: %.5f\n\tLongitude: %.5f \n\tAltitude: %.5f\n",
            ENTITY_NAME,
            position.latitude / 1e7,
            position.longitude / 1e7,
            position.altitude / 1e2);
```


### ОБРАТНАЯ СВЯЗЬ

Трудности, связанные с площадкой:
1. Удаленность Сахалина от европейской части России, долгий адаптационный период в связи с разными часовыми поясами;
2. Непредсказуемая погода на острове;

Трудности, связанные конкретно с соревнованиями:
1. Скорее нюанс: долгий запуск системы при использовании цифрового двойника. Возможно, было бы удобнее при внесении изменений в kos пересобирать только его, а sitl и mavproxy оставлять с прошлого запуска;
2. Некорректное поведение реального дрона, связанное с неточностью датчиков определения местоположения (GPS модуль, компас, барометр). Пришлось добавить простейшую обработку резких скачков координат. В целом, это было ожидаемо...

Идеи для развития проекта и соревнований:
1. Расширить проект в части возможности внесения изменений в аппаратную часть копетера, изменение архитектуры взаимодействия различных частей дрона (то, что было заявлено в продвинутом уровне);

Положительные стороны:
1. 