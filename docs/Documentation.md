# Документация по прохождения кибер-препятствий

## Посадка, по событию из ОРВД

Для решения задачи использовали метод 
`/api/fly_accept` из ОРВД, логика следующая:
1. `Запускаем быстрые сообщения в ОРВД` 
2. Если пришло сообщение `$Arm: 0#`
3. Если пришло сообщение `$Arm: 1#` - останавливаем полёт `pauseFlight()` 
4. `Запускаем медленные сообщения в ОРВД` 
5. Если пришло сообщение `$Arm: 0#` - возобновляем миссию `resumeFlight()`

Пришло сообщение - значит сообщение начинается на эти символы

Медленные сообщения - обычные сообщения, 
которые в циклах пытаются много раз повторить одно и то же действие
при не удачном запросе.

Быстрые сообщения - та же отправка и проверка, 
но без бесконечных циклов.

Цель быстрых запросов - как можно быстрее вернутся в основной 
цикл и в нём проверять другие позиции, например что у нас 
дрон не туда полетел и мы отключим двигатели быстрее.

## Работа с местоположением

### Работа с местоположением (описательная часть)

У нас есть несколько структур
```cpp
struct Position {
    int latitude; // Широта
    int longitude; // Долгота
    int altitude; // Высота
    int homeAltitude; // Высота относительно дома
};

// Для работы со скоростью
struct DynamicPosition {
    Position currentPosition; // Текущее местоположение дрона
    Position lastPosition; // Последняя позиция
    long double lastTimeUpdatePosition; // Время, когда 
};
```

В `DynamicPosition` мы обновляем `lastPosition` и `lastTimeUpdatePosition` относительно валидатора скорости `validateSpeed(...)`

### Изменение waypoint`а во время полёта

Для контроля отклонения дрона от заданной траектории в полете необходимо отслеживать достижение следующих точек миссии (waypoints). 
Для решения данной задачи в основном цикле выполнения программы модуля kos происходит получение расстояния между `текущим местоположением` дрона и `следующей точкой `полетного задания. В случае, если рассчитанное расстояние меньше заданного ( `5 метров`), программа считает, что коптер достиг следующей точки точки. 

### Увеличение скорости (validations.validateSpeed)

Как выше описали, мы сохраняем время последней отсечки и точку в которой дрон был на тот момент. 
Зная расстояние и время, можно посчитать скорость `speed = distance / deltaTime`. 
Если происходит превышение `2 м/с`, мы отправляем запрос `changeSpeed(2)` на снижение до `2 м/с`.

### Не своевременный сброс груза

При получении миссии, выполняем поиск точки сброса груза, 
после этого в основном цикле проверяем местоположение дрона 
и считаем расстояние до точки сброса.

### Сбой полётного контроллера / не реагирование на команды модуля безопасности

Если `расстояние от заданной троектории больше 5 метров или высота больше 1.5 м` на протяжении `3 секунд`, то kos активирует kil switch. 
При этом, при отклонении от траетории на расстояние `3 метра` или превышение высоты на `0.5 м`, kos начинает с периодичностью 700 мс отправлять запрсы в автопилот на изменение следующей точки полетного задания или высоты миссии соответственно.

## Описание работы вспомогательных функций

### Определение времени (currentTime)

Для определения текущего времени использовали
время из библиотеки `coresrv/time/time_api.h`

```cpp
RtlTimeSpec time;

if (KnGetSystemTime(&time) != rcOk) {
    fprintf(stderr, "[%s] ERROR get time\n", ENTITY_NAME);
}

return time.sec * 1e3 + time.nsec / 1e6;
```

### Получение расстояние (getDistance)

#### От точки до точки

Используя формулу расстояния по координатам для земного шара, находим расстояние 
по плоскости сферы

```cpp
2 * R_EARTH * sqrt(
            pow(sin(dLon / 2) * cos(lat), 2) +
            pow(cos(dLon / 2) * sin(dLat / 2), 2)
    );
```

Далее через корень и степень прибавляем расстояние по высоте:
```cpp
sqrt(
    pow(getDistance(
            toRadiansAngle(pos1.longitude),
            dLon,
            toRadiansAngle(pos1.latitude),
            dLat), 2) +
    pow(dAlt, 2)
```

#### Получить расстояние от точки до прямой

Тут формула немного сложнее, но суть примерно та же что и выше
```cpp
// x, y, z - названия условные

// dx - изменения по широте у отрезка
// dy - изменения по долготе у отрезка
// dz - изменения по высоте у отрезка

// dxc, dyc, dzy - изменения для точки для которой ищем расстояние 

double t = (dxc * dx + dyc * dy + dzc * dz) / (dx * dx + dy * dy + dz * dz);

if (t > 1)
    t = 1;
else if (t < 0)
    t = 0;

double distance = sqrt(
        pow(-dxc + dx * t, 2) +
        pow(-dyc + dy * t, 2) +
        pow(-dzc + dz * t, 2));
```

### Получение скоорсти (getCurrentSpeed)

Внутрь передаём структуру DynamicPosition, которая содержит время, 
и последнюю точку, использовав getDistance между двумя точками - мы можем
рассчитать расстояние.
Считаем, что на рассматриваемом учатке скорость постоянно, поэтому для ее вычисления используется формула
```cpp
currentSpeed = distance / time;
```


### Проверка остановки миссии (needPauseMission) 

Делает запрос в ОРВД и проверяет нужна ли посадка, работает так же по принципу, 
если дрон летит - нужно как можно чаще проверять его полёт.

### Отправка логов в ОРВД (sendLogs)

GET запрос `/api/logs`, с query параметрами `id` и `log.
Был выделен метод упрощающий отправку логов
```cpp
void sendLogs(char *log) {
    char logResponse[1024] = {0};
    char message[512] = {0};
    snprintf(message, 512, "/api/logs?%s&log=%s", BOARD_ID, log);
    sendSignedMessage(message, "send_log", RETRY_DELAY_SEC);
}
```

Нюанс только в том, что это http запрос и все пробелы надо заменять на строку `%20`, 
чтобы корректно отправлять пробелы, так же и с другими пробельными символами.

### Логгирование позиции (printPosition)

Для упрощения логгирования структуры `Position` добавили метод, 
который позволяет упрощённо логгировать структуру

```cpp
fprintf(stderr, "[%s] Info Position:\n\tLatitude: %.5f\n\tLongitude: %.5f \n\tAltitude: %.5f\n",
            ENTITY_NAME,
            position.latitude / 1e7,
            position.longitude / 1e7,
            position.altitude / 1e2);
```

### Ограничение частоты запросов в автопилот и модуль GPS

Чтобы не перегружать автопилот запросами на изменение миисии был реализовани алгоритм различных задержек для различных модулей:
1. Запрос на изменение скорости отправляется не чаще 1 раза в секунду;
2. Запрос на изменение высооты полета отправляется с периодом 700 мс;
3. Запрос координат от GPS-приемника раз в 300 мс;
4. Валидация скорости каждуые 700 мс.


### ОБРАТНАЯ СВЯЗЬ

Трудности, связанные с площадкой:
1. Удаленность Сахалина от европейской части России, долгий адаптационный период в связи с разными часовыми поясами;
2. Непредсказуемая погода на острове;

Трудности, связанные конкретно с соревнованиями:
1. Скорее нюанс: долгий запуск системы при использовании цифрового двойника. Возможно, было бы удобнее при внесении изменений в kos пересобирать только его, а sitl и mavproxy оставлять с прошлого запуска;
2. Некорректное поведение реального дрона, связанное с неточностью датчиков определения местоположения (GPS модуль, компас, барометр). Пришлось добавить простейшую обработку резких скачков координат. В целом, это было ожидаемо...

Идеи для развития проекта и соревнований:
1. Расширить проект в части возможности внесения изменений в аппаратную часть копетера, изменение архитектуры взаимодействия различных частей дрона (то, что было заявлено в продвинутом уровне);

Положительные стороны:
1. 